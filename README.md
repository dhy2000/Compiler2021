# 新增文法代码生成题目

支持单个变量的自增自减:

- `<Stmt> ::= <LVal> '+' '+' ';'`
- `<Stmt> ::= <LVal> '-' '-' ';'`

限制:
- 自增自减只作为单独的语句出现 (例如 `i++;`)，不会作为子表达式 (即不出现 `a[i++] = 1` 等)。
- 只出现单个变量的自增自减 (例如 `i++`)，不会出现数组的自增自减 (即不出现 `a[i]++` 等)。

## 解决方案

- 词法分析新增词语 `++`, `--`
  - `INC`: `++`
  - `DEC`: `--`
- 语法分析新增语句 `UnaryStmt`
  - 含有一个 `LVal` 和一个符号 (只能是 `++` 或 `--`)
  - 语法分析时属于简单语句 `SplStmt` (以分号结尾, 不产生新的 `<Block>`)
    (本编译器对文法进行了一些改写，`SplStmt` 不是原文法的非终结符, 为自行新增成分。包括赋值语句, 表达式语句, 输入输出语句, `break`/`continue` 等以分号结尾的 `<Stmt>` 中不包括分号的成分)
- 语法分析器 `parseSimpleStmt` 方法: 先行分析完一个 `LVal` 后判断下一个预读符号
  - 赋值符号 `=`: 继续解析为赋值语句 (课下已有)
  - 自增 `++` 或自减 `--`: 解析为自增自减语句 `UnaryStmt` (课上新增)

## 注意事项

上述将 `++` 与 `--` 当成一个词的实现方法存在一处坑点: 连续的两个 `+` 或 `-` 号除了作为自增自减运算符一个整体以外，还可能分别作为表达式运算符和一元运算符，示例如下：

- `i++1;` 是一个合法的 `<Stmt> ::= <Exp>`，其中第一个 `+` 为 `<AddExp>` 中的加号，第二个 `+` 作为 `<UnaryExp>` 中的正号。
  - 该语句语义等同于 `i + (+1)`
  - 若将该 `++` 匹配成一个自增运算符，则导致语法分析发生错误。

该坑点的解决方法：对匹配自增符号 `++` 和自减符号 `--` 的正则表达式增加先行断言: 只有当 `++` 或 `--` 后跟随分号 `;` (`++` 和 `;` 之间允许零个或多个空白符) 时才匹配，否则不匹配，当成独立的两个 `+` 或 `-` 处理。

最终实际使用的正则表达式 (`+` 在正则表达式中需要转义, `\s` 表示空白字符, 在 Java 字符串中应以 `\\` 表示正则表达式中的一个 `\`):

- 自增: `\+\+(?=\s*;)`
- 自减: `--(?=\s*;)`

> 考后意识到上述处理方法仍有缺陷，该方法不能处理 `++` 或 `--` 与分号之间含有注释，例如 `i++ /* SysY 2021 */ ;`，但评测没出现这样的测试点。

## 样例

```c
int test;
int arr[5] = {1, 2, 3, 4, 5};

int main(){
    test = getint();
    int n = 5;
    n++;
    n--;
    int c = n;
    test++;
    printf("%d %d\n", test, c);
    // arr[3]++; // will not appear
    int b = 1;
    if (b == 1) c++;
    else b++;

    printf("%d %d\n", b, c);
    test--;
    printf("%d\n",test);
    return 0;
}
```

## 考试结果

Pass all (5/5)

其中 `testfile3` 和 `testfile4` 存在形如 `i++1` 的坑点。
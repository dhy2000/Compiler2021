# 《编译技术》课程设计 申优文档

## 概述

本文档为编译技术课程设计的申优文档，内容主要分为两部分，一是整个编译器各部分设计中的困难点与解决方案，二是代码生成所做的优化。

## 一、编译器设计中的困难与解决方案

详细完整的编译器架构设计在设计文档中已经编写过，此处不再赘述，仅针对重要的困难点与解决方案进行说明。

### 词法分析

在做词法分析前，首先读取源代码文件的内容并暂时存储。为了便于在词法分析中标行号，读取源代码采用的方式是按行读取，按行存储，读取完成后得到一个由每一行源代码组成的数组。

对于词法分析得到的词语成分（ `Token` ），首先为其创建一个抽象的基类 `Token`，并根据词法种类分别创建不同的实现类。对于词法种类的标识，采用 Java 中的枚举类型，并在每种词法成分标识的枚举对象中存储能识别这个词语的正则表达式。在进行词法分析时，维护一组表明当前分析到的行列位置的下标，从前向后移进这组下标，首先跳过注释，其次根据正则表达式逐一匹配，分析出匹配到的词法成分，将其存入词法分析结果的列表中。

在完成词法分析的过程中主要遇到了如下的 bug:

- 注释：在跳过形如 `/* ... */` 的块状注释时，识别到 `/*` 应跳过 2 个字符但误写成了 1 个，导致遇到 `/*/ .... */` 时提前结束了注释的识别
- 前缀：存在一些形如 `main1`, `int_` 等以标识符作为前缀的单词，这些单词易误判为标识符，解决该 bug 的方法有（本人实际采用第一种）
  - 在识别关键字的正则表达式中引入后置否定断言，例如 `main(?![_A-Za-z0-9])` 可以匹配 `main` 而不会匹配到 `main1` 
  - 暂时将关键字识别为标识符，并进行进一步的判断

### 语法分析

这部分的主要难点在于：

- 如何存储语法分析得到的语法树
- 消除左递归的同时正确还原左递归文法的语法树结构
- 如何处理 FIRST 集相交的非终结符

对于语法树而言，为了后续进行语义分析的方便，本人在编译器中对于每种非终结符建立了一个类，语法树就是这些非终结符的类之间的引用关系。所有的语法树节点都共同实现了一个能输出语法分析结果的接口。语法树节点之间也根据语法分析的逻辑组成部分进行了分类整理。对于文法中以"或"连接的非终结符，对"或"的每一种情况建立一种节点类，并令这些节点类共同实现一个标记接口（没有方法的接口），这样这个非终结符更上层的非终结符只需持有标记接口的实例即可。

对于表达式而言，由于同优先级运算符是自左向右运算，即优先左结合，这样写出来的文法自然是左递归的，而左递归文法无法进行递归下降分析，所以需要对文法进行改写。但是语法分析结果的输出必须按原文法的结构，因此对于二元的表达式而言，本人的处理方法是让这些二元运算的语法树节点从二叉变成多叉（即 `+` 不再表示二元的加法，而表示连续求和；`-` 也并入连续求和中，只在这一项上打标记）。对应的，左递归文法也改写成用 EBNF 描述的循环形式的文法。得到循环形式的语法树后，按照从左到右的顺序输出并及时进行归约即可达到与左递归文法等价的输出效果。

对于非终结符之间 FIRST 集相交的情况，采用预读的方式处理，提前预读 2 个甚至 3 个符号来判断接下来的分析方向。

### 中间代码

中间代码的语句设计参考编译器设计文档或课程组提供的中间代码指导书，本环节主要的一个难点是如何组织中间代码的语句，形成完整的中间代码。

本人的编译器中，中间代码默认划分了基本块，每个基本块有一个标签用于作为跳转语句的目标，同时每个基本块的末尾保证了以跳转语句或返回语句作为结尾。在基本块内，语句之间以链表形式组织。由于 Java 自带的 `LinkedList` 对于一些链表操作的自由性较差，因此编译器中自行设计封装了一种链表节点的基类，并令所有的中间代码语句类均继承该基类。

### 中间代码虚拟机

为了验证中间代码生成的正确性，同时对目标代码翻译提供一定的指导作用，编译器内置了解释执行中间代码的虚拟机（解释器），在虚拟机内维护运行栈、临时变量池等状态信息，逐条语句解释执行中间代码，执行到输入输出语句时可以进行 IO，由此可以方便地验证中间代码的生成是正确的。

### 目标代码

目标代码同样采用链表形式组织（不再保留基本块信息，直接按 PC 顺序组织指令）。在翻译目标代码时实现了临时寄存器的分配，在后面的优化部分会提及。

## 二、代码生成优化

### 乘除法优化

#### 简单优化

本编译器对于含有常数的乘除法进行了较为简单的优化。对于乘法，如果因数之一是 2 的幂，则将乘法指令转化为一条左移指令。除法同理，除以 2 的幂可以转化成右移指令。但对于负的被除数而言，非整除时的取整和右移指令的结果相差了 1 ，故需要在右移后对被除数的正负性进行判断，并对商进行修正。

#### 进阶优化

编译器针对除数为常数的除法进行了更加高级的优化，将所有除数为常数的除法指令根据论文及开源代码（该优化参考了 `libdivide` 库的实现）中提供的算法转化为乘法指令与一系列移位指令的组合，消除了除数为常数的除法指令。

### 基本块内临时寄存器分配

采用寄存器池分配临时寄存器，寄存器池模拟 Cache，在基本块内对于一个变量，如果还没有分配临时寄存器且仍有空闲的临时寄存器，则为其分配临时寄存器；如果临时寄存器已经用尽，则需要置换出一个变量以为新变量分配寄存器。由于中间代码中对变量的种类进行了区分，分为局部变量和临时变量；局部变量有相对当前栈指针固定的偏移地址，而临时变量没有地址且先定义后使用，所以如果被置换出去的是局部变量，直接写回内存；对于临时变量的置换，为了节约内存空间，对基本块内的临时变量预先进行了引用计数，当临时变量的引用计数已经减到 0 时，主动释放该临时变量的寄存器。而若临时变量引用计数尚未归零即被置换出临时寄存器池，则为其分配栈上地址偏移，即这个临时变量转化为局部变量，回写内存。

由于这种寄存器分配方式仅在基本块内有效，当翻译到基本块末尾的跳转指令前，所有已经分配的寄存器都要释放并将变量写回内存。

### 窥孔优化

本部分主要是针对跳转指令的窥孔优化。首先，如果一个跳转指令跳转到其紧邻的下一条指令，则这个跳转指令可以被删除掉。另外，如果沿跳转方向有多条跳转指令（如 `j 1`, `1: j 2`, `2: j 3` ......），并且中途过渡的跳转指令独占一个基本块，则可将这些跳转指令合并成同一条，并删除多余的基本块。
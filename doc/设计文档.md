# 《编译技术》课程设计 第二阶段文档

本文档为编译器实现的各个阶段（包括词法分析、语法分析、符号表设计、错误处理、中间代码生成、目标代码生成等）的设计文档。文档正文将分阶段详细阐述每一部分的设计。

## 词法分析

词法分析代码位于 `frontend.lexical` 包中，包括词语类，词语列表以及词法分析器类。 词法分析实现起来较为简单，该环节将源代码文件中字符串形式的代码拆分成词语，并将分析出的词语成分存在一个 `List` 中用于语法分析。

### 输入文件处理

进行词法分析前首先读取输入文件，在本编译器的设计中，出于后续错误处理需要保留行号，且词法分析的到的词语单元不会跨多行，因此将输入的源代码逐行读入，按行存储。为了便于进行词法分析，针对按行存储的源代码设计了一个类，并维护了当前所读到的行和列。在进行词法分析时只需传递这个类的对象并读取出内容即可。

### 词语成分存储

在本编译器中针对词语成分建立了类来存储，包括一个抽象的基类和若干子类表示不同的词语成分。同时定义了一个枚举类型用来标识当前词法成分的种类。由于 Java 语言的枚举类型功能较为强大，并不只是一个符号而是一个对象，因此可以在枚举类的实例中存储一个代表当前词法匹配规则的正则表达式。

对于具体的一个词语，其存储类存储了当前词语的种类(枚举类), 当前词语的内容，以及所在的行号。

观察词语表，前三种词语 `Ident`, `IntConst`, `FormatString` 具有一定的灵活性(含有有意义的值)，而其他的词语成分仅有结构上的作用，内容是固定的（例如关键词和运算符），因此将前三种词语分别定义类，而所有的关键词和符号统一定义一个类即可。

### 词法分析器

设计完词语的存储类后就是词法分析器的编写。词法分析器的大体工作流程为：

- 如果已经到了输入的末尾，则结束
- 跳过当前位置往后的空白符号，找到第一个非空白符
- 如果面前是注释，则跳过注释，而后继续循环读入
- 否则依次用枚举类中定义过的词法成分进行正则匹配，匹配到则实例化词语类并存入词语列表

根据上述流程即可编写出词法分析器的代码，设计和编码的过程不太困难，故不在此赘述。

### 需要注意的事项

在编写词法分析器的过程中遇到了一些比较容易错的点，在此记录：

- 对于块注释，匹配完起始符号 `/*` 后应跳过 2 个字符而不是 1 个字符，否则如遇到 `/*/` 则会错误识别到 `*/` 而提前结束注释。
- 双字符的运算符匹配顺序应先于单字符运算符（有公共前缀，例如 `==` 应匹配为双等号而非两个单等号，即**贪心匹配**）
- 同理，可能存在一些标识符以关键词作为前缀，例如 `inta`，不能错误匹配出 `int` （同样需满足贪心匹配的原则）
  - 该问题的解决方法有两种，一种是首先匹配出一个 `Ident`，再进行关键词的判断
  - 二是统一采用正则表达式，但是对于关键词的匹配规则需加入后置断言（关键词后不能有数字/字母/下划线从而连成一整个标识符），例如 `int(?![_A-Za-z0-9])`

至此，词法分析环节的设计与编码便完成了。

------

## 语法分析

语法分析代码位于 `frontend.syntax` 包中，包括语法树节点类和解析器类。

### 语法树及其节点

语法树采用多种不同的节点类进行表示。为了方便管理编译作业要求的语法分析输出，这里定义一个接口 `Component` 用于输出语法成分。

对于文法的每种成分(非终结符)，建立一种语法树节点类，并用属性来存储其组成成分（词语(终结符, 叶节点)和子节点(非终结符, 非叶节点)）。对于组成成分存在 "或" 关系的非终结符，对其每个具体方向建立类，并让这些类实现同一个接口。

由于编译实验设计到的文法条目较多，工程量相较上学期面向对象课程的表达式求导单元是一个飞升，因此为了简化编译器的开发难度，将整个 `SysY` 文法按照不同的逻辑层次进行分类，分别针对每一类依次分析和编码，从而不太痛苦、不丧失很多信心地完成语法分析任务。根据语法成分出现的层次，分为：表达式、语句、变量定义、函数定义四大类。

注：在语法分析中，`<BlockItem>`, `<Decl>`, `<BType>` 三种成分不需要输出。

#### 表达式

首先进行表达式的解析（与 OO Unit1 比较接近），表达式作为整个编译文法中较为基础的成分，其解析同其他语法成分也可以相对独立，因此将其作为一类语法成分，在工程代码中对应到 `expr` 子包。

与表达式相关的文法如下：

```text
<Exp>           := <AddExp>
<Cond>          := <LOrExp>
<LVal>          := Ident { '[' <Exp> ']' } // 普通变量，一维或二维数组
<PrimaryExp>    := '(' <Exp> ')' | <LVal> | <Number> // 三种情况, 子表达式, 左值, 字面量
<Number>        := IntConst
<UnaryExp>      := <PrimaryExp> | <Ident> '(' [ <FuncRParams> ] ')' | <UnaryOp> <UnaryExp> // PrimaryExp 或者 FunctionCall 或者含有一元运算符
<UnaryOp>       := '+' | '-' | '!'  // '!' 仅能在条件表达式中出现
<FuncRParams>   := <Exp> { ',' <Exp> } 
<MulExp>        := <UnaryExp> | <MulExp> ( '*' | '/' | '%' ) <UnaryExp>
<AddExp>        := <MulExp> | <AddExp> ( '+' | '-' ) <MulExp>
<RelExp>        := <AddExp> | <RelExp> ( '<' | '>' | '<=' | '>=' ) <AddExp>
<EqExp>         := <RelExp> | <EqExp> ( '==' | '!=' ) <RelExp>
<LAndExp>       := <EqExp> | <LAndExp> '&&' <EqExp>
<LOrExp>        := <LAndExp> | <LOrExp> '||' <LAndExp>
```

对于现有的文法, 在**不违反原文法**基础上为了简化存储结构，进行一些修改(以及消除左递归)

```text
<LVal>          := Ident { '[' <Exp> ']' } // public class LVal { ident, class Index, List<Index> }
<PrimaryExp>    := <SubExp> | <LVal> | <Number> // Look forward: '(' :: <SubExp>, <Ident> :: <LVal>, <IntConst> :: <Number>
<SubExp>        := '(' <Exp> ')'
<Number>        := IntConst   // 该节点只存一个 Token
<BaseUnaryExp> := <PrimaryExp> | <FunctionCall> // 即不包含 <UnaryOp> 的 <UnaryExp>
// <BaseUnaryExp> 需要向前看 2 个符号: Ident '(' :: <FunctionCall>, Ident :: <LVal>, '(' :: <SubExp>, IntConst :: <Number>
<FunctionCall>  := <Ident> '(' [ <FuncRParams> ] ')'
<FuncRParams>   := <Exp> { ',', <Exp> } // List<Exp>
<UnaryExp>      := { <UnaryOp> } <BaseUnaryExp> // List<UnaryOp>, UnaryOp 包含在 UnaryExp 内部，不单独建类
// ---------- 分割线 ----------
<MulExp>        := <UnaryExp> { ('*' | '/' | '%') <UnaryExp> }    // 消左递归, 转成循环形式
<AddExp>        := <MulExp> { ('+' | '-') <MulExp> }
<RelExp>        := <AddExp> { ('<' | '>' | '<=' | '>=') <AddExp> }
<EqExp>         := <RelExp> { ('==' | '!=') <RelExp> }
<LAndExp>       := <EqExp> { '&&' <EqExp> }
<LOrExp>        := <LAndExp> { '||' <LAndExp> }

<Exp>           := <AddExp> // public class Exp extends AddExp { }
<Cond>          := <LOrExp> // public class Cond extends LOrExp { }
<ConstExp>      := <AddExp>
```

对于分割线后面的几种成分（`MulExp`, `AddExp`, `RelExp`, `EqExp`, `LAndExp`, `LOrExp`)，其共同特点为由结构相同的左递归文法改成的，连续的从左向右结合的二元表达式，可以根据它们的共同特性提取出一个抽象的父类，基本结构如下：

```java
import frontend.lexical.token.Token;

public abstract class MultiExp<T> { // T: 当前类低一个层次，例如 AddExp 的 T 为 MulExp
    private final T first;
    private final List<Token> operators;
    private final List<T> operands;
}
```

而以上几类具体的表达式除了自身种类，运算符种类和子节点种类不同以外，结构是很相近的（包括其输出方式），因此将它们的输出方法也在 `MultiExp` 抽象类中默认实现：

```java
import frontend.syntax.Component;

import java.io.PrintStream;

public abstract class MultiExp<T extends Component> implements Component {
    private final String name;

    @Override
    public void output(PrintStream ps) {
        // 先输出第一个节点, 按自身的 `name` 输出
        // 然后循环遍历跟随的节点，每输出完一个子节点后，输出一遍自身的 `name` (等价于输出一棵从左向右结合的树)
    }
}
```

处理完以上成分之后还有两个 `<Exp>` 和 `<Cond>`，这两种节点只是在 `<AddExp>` 和 `<LOrExp>` 上套了一层，为了输出方便还是创建相应的类，持有其套的类的实例并重写输出方法。对于 `ConstExp` ，将其作为 `Exp` 的子类。

另一方面，对于分割线以上的语法成分，它们之间没有太多共同点，因此针对每种语法成分分别建立类即可。

由上，根据上面的分析，在编写代码时将 `expr` 包内的语法成分分成两大类（也就是拆分成两个包）：一元表达式和多元表达式。其中 `unary` 包含分割线以上的一元表达式，而 `multi` 包含分割线以下的多元表达式。

#### 语句

从表达式更往上一层的语法是语句 `Stmt` 及其相关的成分。语句是 SysY 语言（也是 C 语言）代码中的一个重要的单元。和语句相关的文法如下：

```text
<Stmt> := <LVal> '=' <Exp> ';'
    | [<Exp>] ';'
    | <Block>
    | 'if' '(' <Cond> ')' <Stmt> [ 'else' <Stmt> ]
    | 'while' '(' <Cond> ')' <Stmt>
    | 'break' ';' | 'continue' ';'
    | 'return' [<Exp>] ';'
    | <LVal> '=' 'getint' '(' ')' ';'
    | 'printf' '(' FormatString { ',' <Exp> } ')' ';'

<BlockItem> := <Decl> | <Stmt>  // <Decl> 目前还未分析，相应代码暂时留空，下一节补上

<Block> := '{' { <BlockItem> } '}'
```

这段文法中，`Stmt` 的可选项(分支)较多，且每种语句的含义有很大不同，为了便于在以后的阶段分开处理，因此将 `Stmt` 的每种分支进行命名并作为独立的语法成分拆分出来。文法改写如下：

```text
// 以分号结尾的简单语句
<AssignStmt>    := <LVal> '=' <Exp> // 这些新增非终结符的组成不含分号
<ExpStmt>       := <Exp>            // 空语句放到最后了
<BreakStmt>     := 'break'
<ContinueStmt>  := 'continue'
<ReturnStmt>    := 'return' [<Exp>]
<InputStmt>     := <LVal> '=' 'getint' '(' ')'
<OutputStmt>    := 'printf' '(' FormatString { ',' <Exp> } ')'
<SplStmt>       := <AssignStmt> | <ExpStmt> | <BreakStmt> | <ContinueStmt> 
    | <ReturnStmt> | <InputStmt> | <OutputStmt> // <SimpStmt> 是以分号结尾的语句(不含分号)的合集
// 复杂的语句
<IfStmt>        := 'if' '(' <Cond> ')' <Stmt> [ 'else' <Stmt> ]
<WhileStmt>     := 'while' '(' <Cond> ')' <Stmt>
<CplStmt>       := <BranchStmt> | <LoopStmt> | <Block>

<Stmt>          := ';' | <SplStmt> ';' | <CplStmt>    // 将分号放在这里统一处理

<BlockItem>     := <Decl> | <Stmt>

<Block>         := '{' { <BlockItem> } '}'
```

在改写后的 `Stmt` 相关文法中，大多数分支只需要向前看 1 个符号即可够用，但判断 `AssignStmt`, `InputStmt` 和 `ExpStmt` 需要面临 `LVal` 与 `Exp` 的选择，在这里向前看的符号数量是难以确定的。回顾前一节刚刚写完的表达式部分，可以看出 `LVal` 是 `Exp` 的"子集"（即，若一个短语能够由 `LVal` 推导出来，则一定能被 `Exp` 推导），因此在向前看完其他符号后，直接进行一个 `Exp` 的 parse，由于递归下降对语法成分的匹配是贪心的（尽可能多匹配），因此若解析出来的 `Exp` 仅含有一个 `LVal` 则一定是 `LVal`，反之则不是，由此即解决了 `LVal` 和 `Exp` 的区分问题，进而完成语句部分的语法树节点类建模和解析器的编写。

#### 变量声明

变量声明 (`Decl`) 作为和 `Stmt` 同级（均属于 `BlockItem`）但有区别（可以位于函数外定义全局变量）的语法成分，可单独分出一类进行建模与解析。

相关的文法如下：

```text
<Decl>          := <ConstDecl> | <VarDecl>
<BType>         := 'int'
// Const
<ConstDecl>     := 'const' <BType> <ConstDef> { ',' <ConstDef> } ';'
<ConstDef>      := Ident { '[' <ConstExp> ']' } '=' <ConstInitVal>
<ConstInitVal>  := <ConstExp> | '{' [ <ConstInitVal> { ',' <ConstInitVal> } ] '}'
// Var
<VarDecl>       := <BType> <VarDef> { ',' <VarDef> } ';'
<VarDef>        := Ident { '[' <ConstExp> ']' } | Ident { '[' <ConstExp> ']' } '=' <InitVal>
<InitVal>       := <Exp> | '{' [ <InitVal> { ',' <InitVal> } ] '}'
```

由于上述文法中，常量声明和非常量声明是类似的，为了减少解析器中可能存在的重复代码，对文法进行改写：

```text
<BType>         := 'int'
<Decl>          := ['const'] <BType> <Def> { ',' <Def> } ';'    // 'const' 修饰若有，则表示常量
<ArrDef>        := '[' <ConstExp> ']'       // 如果没有则不是数组
<Def>           := Ident { <ArrayDef> } [ '=' <InitVal> ]   // 如果是常量声明则必须有 InitVal
<InitVal>       := <ExpInitVal> | <ArrInitVal>
<ExpInitVal>    := <Exp>
<ArrInitVal>    := '{' [ <InitVal> { ',' <InitVal> } ] '}'    // 语义分析时要求必须个数与维度对应
```

改写后的文法相较原始的文法，将常量与变量进行了一些统一，同时将变量的初值进行了一定的层次化处理。

由于改写的文法需要保证和原来的文法等价（至少要保证语法分析作业的输出是一致的，并且语义不能变），因此仍然需要对是否为常量进行区分，而区分的方式采用在相应语法节点中添加一个是否要求是常量的 `boolean` 属性，并在解析器的相应方法中通过传参来传达该信息。在进行输出和语义分析时，只需查看当前节点是否有常量标记即可区分是 `Const` 还是 `Var`。

#### 函数定义

行百里者半九十，完成了前面大约四分之三的工作量后，到了最后的一组文法了。函数相关的文法如下：

```text
<FuncDef>       := <FuncType> Ident '(' [<FuncFParams> ] ')' <Block>
<MainFuncDef>   := 'int' 'main' '(' ')' <Block>
<FuncType>      := 'void' | 'int'
<FuncFParams>   := <FuncFParam> { ',' <FuncFParam> }
<FuncFParam>    := <BType> Ident [ '[' ']' { '[' <ConstExp> ']' } ]
```

这部分文法解析难度相比前面较简单，不需要改写文法，按照原文法进行解析即可。

终于，完成了上述所有语法成分的解析后，以最终的一条入口文法 `CompUnit` 来宣告语法分析作业进入了尾声：

```text
<CompUnit>      := { <Decl> } { <FuncDef> } <MainFuncDef>
```

对于这一条文法，一大难点是如何判断接下来即将解析到的是 `Decl` 还是 `FuncDef` 还是 `MainFuncDef`。和前面类似，采取向前看符号的方法，由 `Decl`, `FuncDef`, `MainFuncDef` 的公共前缀有 2 个符号（类型，标识符），因此向前看三个符号即可确定接下来解析的方向。

由此，便完成了整个 SysY 2021 文法的语法分析。本节重点从语法成分的角度分析并设计了数据结构来存储语法成分，关于语法分析器编写的一些事项位于下一节中。

### 语法分析器 (`Parser`) 编写

语法分析器 (`Parser`) 采用递归下降的方法编写，同样为了使整个编译器工程更加模块化，根据上一节对语法成分的分类，对每一类语法成分编写一个解析器类，解析器类之间结构高度相似，区别仅在其负责解析的语法成分不尽相同。

对于递归下降解析器，其在解析过程中需不停向前读取词法分析后提取出来的词语列表，因此需要一个读取头 "指针" 指向当前读取词语列表的位置（在面向对象语言中，这个 "指针" 实际就是迭代器）。由于实验给出的文法不同非终结符的 `FIRST` 集是相交的，为了避免理论上可能出现的回溯，在解析过程中需要采取 "向前看" 的方式来实际确定下一步需解析的语法成分。

#### 迭代器的选取

由于 Java 中普通的迭代器 `Iterator` 只能单向前进，不能停下取当前位置的值, 在这种情况下取出向前看的符号是一个不可逆的过程，如果向前看的符号数量不确定，则取出符号判断不属于某个分支后无法放回，将会给下面的子解析程序结构造成较大破坏。为了使各语法成分的解析程序相对保持完整，采用支持双向前进的 `ListIterator` 替代普通的 `Iterator`，既可以前进 (`.next()`) 取出符号，也可以倒退 (`.previous()`) 放回符号。（ Java 的迭代器是不具备 C++ 迭代器可以直接以指针解引用运算符取出当前值的性质的，若想只取出一个值向前看一步，则只能先调用 `next` 方法取出值并前进一步，再调用 `previous` 方法倒退一步，回到原来指向的位置）

#### 解析器类的结构

不同类别语法成分的解析器代码结构大同小异：一个解析器对象持有对词语列表的 `ListIterator` 双向迭代器，并有若干解析方法，一个方法对应着一种语法成分。外部使用时，传入词语迭代器实例化一个解析器类，而后调用相应成分的解析方法即可得到对应的语法树节点对象。

#### 向前看符号的实现

对于需要向前看符号才能确定的语法成分，令其解析方法以参数的形式接受其父成分解析程序中向前看取出的符号，而无需再用迭代器取出一遍。（通常的语法成分解析方法入口是不需要传参的，只需要访问读取头迭代器就可以了。） 但对于 `Exp` 等出现位置较为复杂的语法成分，其可能出现在多种不同的父成分下，不同的父成分解析 `Exp` 需要向前看的符号数量也不同，如果仍然采用先取出符号再传参数的方式，`Exp` 及其子成分的解析程序将会较为混乱，为了保持架构的完整性，这里就需要用上 `ListIterator` 的双向特性，若向前看取出的符号不满足其他分支，而接下来又需要走向一个 `Exp` 分支，则回退读取头迭代器，将向前看的符号 "放回去"，再调用 `parseExp` 进行解析。（这种回退并不等同于回溯，可以理解为受限于 Java 迭代器功能的一种折中选择）

------

## 符号表、错误处理与中间代码生成

该部分作为编译器设计的第三阶段，该阶段涉及到的任务较为杂乱，代码也分散在了多个包中，其中符号表与中间代码位于 `middle` 包，错误处理的错误定义和错误表位于 `frontend.error` ，遍历语法树的 Visitor 位于 `frontend.visitor` 中，同时承担了遍历语法树，维护符号表，进行错误处理，生成中间代码等任务。

在上一次的语法分析作业中，已经将词语表进行了语法分析并生成了语法树，对于整个编译器来说，接下来需要对生成的语法树进行遍历，来进行进一步的处理。经过简单的分析发现，错误处理和中间代码的生成可以合在一遍（Pass）内完成，因此在错误处理作业阶段同时完成了中间代码的设计与生成。

本部分文档按符号表、错误处理、中间代码、Visitor 四部分分别展开说明。

### 符号表

根据错误处理作业的要求，需要维护符号表并对变量未定义、类型不匹配等错误进行处理，因此需要在错误处理阶段就进行符号表的维护。

符号表的设计主要包括两个部分：符号表一条表项（一个符号）包含的内容，以及整个符号表之间的组织方式。

符号表总体的组织方式在 Java 中实现起来较为简单，可以分块来维护栈式的结构。每个符号表"块"作为一个对象，用来维护当前层次的运行栈中所含有的变量，同时每个符号表块均指向其父亲（全局符号表可以没有父亲）。符号表块内部用 `Map` 管理，建立符号名到符号表项的映射关系。当需要进行查找符号时，根据此符号表结构可以较为方便地进行递归查找。（判断变量重定义时则不需要递归）

对于一个符号表项而言，首先根据理论课所学，需要包含符号名，类型等信息。在实际编写代码后，对初始设计过的符号表进行了一些补充，形成了最终相对完整的符号表：

- 首先是类型，由于涉及到数组传参以及部分数组传参，因此在编译器中引入了指针类型来与数组类型进行区分（虽然 SysY 没有指针，但是在编译器中可以引入，只要保证结果正确即可）。在指针类型和数组类型中需同时储存其维数以及每一维的长度信息，同时设计了数组类型到指针类型之间的相互转化（体现在后续的中间代码中）
- 其次是对于常量和全局变量的处理。由于数组定义中长度可以是 `ConstExp` ，且数组的长度必须在编译期确定，同时常量定义中的初始值也是 `ConstExp` ，因此需要编译器能够在编译期就预处理所有的常量，并在编译期计算所有的 `ConstExp` 。另外全局变量由于一定出现在函数前，因此全局变量的初始化也可以在编译期确定。因此，需要在符号表中存储变量的初始化值，以及是否为 `const` （用来处理常量赋值错误），另外在 Visitor 中也需要支持遍历 `ConstExp` 这部分的语法树并直接计算出结果。
- 最后，由于有局部数组的存在，局部数组难以全部分配到寄存器里，其需要内存空间（位于栈中），而局部变量也有需要放在栈中的时刻，因此为了实现的简易，在符号表中对局部变量和局部数组记录了地址（相对于当前层调用栈栈顶的偏移）

### 错误处理

在建立完符号表后即可在一遍 Visitor 中进行错误处理。在本人实际开发的编译器中，错误处理与中间代码生成是写在一起的，但在文档中的本节只讲述错误处理。

首先对于 `i`, `j`, `k` 三种错误，仅属于语法层次，处理起来最容易，只需判断语法树中对应相应词语的节点是否为 `null` 即可。但是这里的坑点在于需要在语法分析阶段为这些错误预留扩展空间，对 `follows` 符号的判断需要进行一定的修改，保证当括号或分号不存在时能正确跳过该符号，而不是直接抛出异常导致语法分析停止。对于 `a` 类错误的处理也较为简单，只需要在遇到 `FormatString` 时对字符串的内容进行检查即可。

后续的错误处理大多只需要按部就班按照文档定义的要求来进行即可。在本文档中只单独提一个错误：函数参数类型不匹配，为了实现这个错误的处理，在编译器中需要支持"推断出一个表达式的类型"，该功能的实现与符号表及中间代码的设计均有关联。而对于数组相关的表达式而言，引入了指针类型也降低了开发的难度。

错误处理这部分没有太多需要设计的内容，主要的难点在于 debug 非常痛苦，没有辅助测试用例库的帮助（但是可以用语法分析的辅助用例库来检查有没有将正确的程序误报为错误），只能反复面向评测机提交试错，而难以建立本地测试的解决方案（自己造测试数据设计到太多 Undefined Behavior ），而 debug 也分为两类，一类是得分为 0% 或者 Runtime Error，对于自己的编译器而言是抛出了异常导致的，可能是语法分析阶段拋异常，也可能是遍历语法树的 Visitor 拋异常；而对于有部分分的情况则需要对出错的测试点是否含有某种错误进行排查，排查到相关的错误类型后，就面对文档和代码思考到底哪里处理的不全，并进行一次次的尝试性修复。

### 中间代码

本编译器的中间代码为自行设计，在设计时一定程度上参考了 MIPS 指令的特点，同时进行了一定的抽象（例如将寄存器抽象掉）。

基本设定为：参与运算的操作数为立即数或者变量（符号），其中立即数的类型为 `int` ，而符号又可分为定义符号（有名称，位于符号表中，类型为符号的类型）和临时符号（用于保存中间结果，通常只在一个基本块内使用，只能为 `int` 或指针类型）。每条中间代码的格式与 MIPS 指令类似，含有助记符和若干操作数。源操作数可以是立即数或符号，目标操作数一定是符号。对于操作数的类型规定根据指令的不同而不同。

中间代码总体的分类：

- 二元运算（两个 `int` 源操作数，一个 `int` 目标操作数）
- 一元运算（一个 `int` 源操作数，一个 `int` 目标操作数）
- 偏移寻址指令（用于访问数组元素，源操作数为数组或指针，以及一个 `int` 类型的偏移，目标操作数为指针）
- 读写内存指令（配合指针使用，用来进行数组元素的读写）
- 输入输出指令
- 函数调用与返回指令
- 分支与跳转指令，其中跳转为无条件跳转，分支为双目标分支（方便划分基本块）

中间代码的指令之间以链表形式组织，最小的单位是一条指令。若干条连续的顺序执行的指令连在一起形成一个块 block，这是中间代码的更上一层单位。每个块对应一个代表其头部的对象，这个对象具有一个标签属性，对应跳转指令跳转到的目的标签。对于函数，其入口也指向了一个带有标签的块。

除了可执行的程序代码以外，本编译器的"中间代码"类还包含了全局变量、全局数组、全局字符串（即 `printf` 语句中的格式字符串）等信息。对于可执行的程序，中间代码类以函数为单位进行存储，用一张表维护函数名与函数的符号表定义，函数的符号表定义中存储了指向这个函数入口块的标签。

中间代码的生成和错误处理均在 Visitor 遍历到语法树的相应节点时进行。

### Visitor

完成了前面的设计后进入了本部分最终的 `Visitor` 的编写。基于前面的设计，Visitor 的编写思路也较为清晰了，除了码量较大，在遇到错误时 debug 需要细心一些。根据不同的语法成分分别生成对应的中间代码描述其行为即可。错误处理在翻译中间代码时顺带进行。

`Visitor` 拿到语法树后对语法树进行遍历，并且对于每种类型的语法树节点均写有相应的方法进行处理。由于中间代码是以链表的形式组织，因此 `Visitor` 中一个很重要的设计就是维护一个（`Visitor` 类内部的）全局指针，指向当前正在组装的 `Block` ，在遍历语法树翻译中间代码时只需要将代码追加到当前块的末尾。随着代码翻译的进行，一个个基本块被组装完成，连起来就形成了完整的中间代码。

对于跨块的行为（分支、跳转、生成新块等），Visitor 遇到相应的语句结构时就实例化一个新的块 `follow` ，然后在当前块的末尾生成一条跳转指令指向新块，然后将"当前块"的指针指向实例化好的新块即可进行下一步的代码翻译。

------

## 中间代码的解释执行

中间代码所处的阶段是编译器前端和后端之间的过渡，由于本编译器的中间代码为自行设计，为了验证翻译的正确性，编译器包含了一个解释执行中间代码的"虚拟机"(解释器)。

首先，虚拟机需要一个 "指针" 指向当前正在执行的中间指令，执行一条中间指令首先判断是哪种指令，而后调用相应的方法去模拟执行。对于变量，本编译器生成的中间代码中有两大类变量：定义变量和临时变量，其中所有的定义变量均分配了内存地址（全局区或者栈区），所以对于所有定义变量的存储，只需要模拟一段线性的内存空间即可；而对于临时变量则用一个从其名称到值的 `Map` 来维护。

对于函数调用，虚拟机需要能够保存现场，并在函数调用返回时恢复现场。对于变量而言，由于定义变量全部位于内存模型中，因此虚拟机需要维护一个栈指针（与 MIPS 中的 `sp` 寄存器功能类似），而临时变量的现场是一个 `Map` ，虚拟机中定义一个栈来储存这一现场即可（进入子函数内，开启一个新的 `Map` 作为函数内的临时变量现场）。除此之外，虚拟机中还定义了保存返回地址的栈与存储返回值的空间，这里的返回地址指的是中间代码中函数调用指令的下一条指令，而返回值只需要一个固定的空间来存储（与 MIPS 中 `v0` 寄存器类似）

有了以上的思路，只需针对先前设计的每一种中间代码指令分别编写其执行行为，就完成了对虚拟机的编写。

编写完成后，利用虚拟机可以方便地检验从前端翻译来的中间代码的正确性。同时由于本编译器的中间代码设计与 MIPS 汇编形式很接近，编写了中间代码的虚拟机也有助于指导接下来最终的目标代码翻译环节。

中间代码的生成与解释执行均位于 `middle` 包，此包名代表编译器的 "中端"，这部分代码包括了变量信息（符号表的条目）、符号表、中间指令的定义、中间代码的存储与解释执行等类。该包中还存在一些针对中间代码的优化器，每个优化器对中间代码进行一次或数次遍历，利用前期自行设计的链表节点，可以很方便地在中间代码中进行增删指令。

------

## 目标代码 (MIPS 汇编) 生成

至此已经来到了编译器的最后一个阶段：目标代码生成，也就是将中间代码翻译为 MIPS 汇编。

由于中间代码的结构与 MIPS 汇编比较接近，因此翻译起来不算特别难，基本就是按块为单位，将每种中间指令翻译为对应的 MIPS 汇编指令，代码结构的变化不算很大。而从中间代码到 MIPS 汇编代码最主要的变化在于抽象的变量要落实到具体的寄存器上。

编译器采用的寄存器分配策略是将所有可用的寄存器全部作为临时寄存器，将这些临时寄存器当作 cache 为变量进行分配。显然，这种寄存器分配方式仅限在基本块内部分配，一旦离开基本块，所有分配了寄存器的变量就全部写回内存。寄存器池的置换算法为 LRU，并在 LRU 基础上针对定义变量和临时变量做了一些区分。对于定义变量，由于它有内存地址，因此被置换出时无条件写回内存。对于临时变量，如果需要写回内存就要分配栈上空间，为了尽可能少分配栈上空间，减少无意义的写回浪费，在翻译一个基本块前对块内所有的临时变量进行了引用计数的统计。临时变量被置换出时，若引用计数已经归零，则这个变量不会再使用，直接将其从寄存器分配表中移除；而若引用计数还不为零，则为其开辟栈上空间，而后将临时变量分配地址，存入栈中。而如果翻译代码翻译到了基本块的末尾，则需清空当前块内的寄存器分配，生成写内存指令将寄存器中的值全部写回内存，而后生成块尾的跳转指令或分支指令。

编译器后端的代码位于 `backend` 包中，包括 MIPS 指令的类，表示 MIPS 硬件（寄存器、内存）的类，组织汇编代码的类以及翻译代码的工厂类。其中用于翻译代码的类结构和中间代码解释执行虚拟机相似，基本是每种指令对应一个方法，在方法中将中间指令翻译成 MIPS 汇编指令。

翻译的 MIPS 汇编代码同样采用链表组织，但不再是中间代码阶段的图结构，而是对中间代码代表的图进行 BFS 得到的线性结构，即一条线性的链表。在这条线性的链表中仍然可以进行一些简单的窥孔优化，对表示一个汇编指令的代码节点进行在线的增删。

对于标签的翻译：在 MIPS 汇编中首先对全局变量不生成标签，因为中间代码中已经存储了变量到地址的对应关系，翻译代码时直接将地址翻译出来，仅保留控制流（分支指令、跳转指令）所必需的标签。另外为了防止标签重名，对于由函数名生成的标签，为其添加特殊的前缀来和内部生成的标签区分开。

------

至此，一个从前端的词法分析语法分析，到中端的语法树、符号表、错误处理、中间代码再到后端翻译成 MIPS 汇编的完整编译器就实现完成了。





// Floyd-Warshall transition closure

const int dist_init[12][12] = {
    {1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
    {1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0},
    {0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0},
    {0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0},
    {1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0},
    {0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0},
    {0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0},
    {0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0},
    {0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0},
    {0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1}
};

const int unused_1dim[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int temp2[12][12] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
}, graph[12][12], temp[12][12] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

void matcpy(int dst[][3 * (2 + 2)], int src[][12]) {
    int i = 0;
    while (i < 12) {
        int j = 0;
        while (j < 12) {
            dst[i][j] = +-+1 * -+-0 + src[i][j];
            j = j + 1;
        }
        i = i + 1;
    }
}

void mat0r(int dst[][12], int src1[][12], int src2[][12]) {
    int i = 0;
    while (i < 12) {
        int j = 0;
        while (j < 12) {
            dst[i][j] = +-+1 * -+-0 + src1[i][j] + src2[i][j];
            if (dst[i][j] > 0) dst[i][j] = 1;
            j = j + 1;
        }
        i = i + 1;
    }
}

int matEql(int src1[][12], int src2[][12]) {
    int i = 0;
    int prod = 1;
    while (i < 12) {
        int j = 0;
        while (j < 12) {
            if (src1[i][j] != src2[i][j]) 
                prod = 0;
            j = j + 1;
        }
        i = i + 1;
    }
    return prod;

}

void NeXT_5tep(int g[][12], int h[][12], int t[][12]) {
    int i;
    0;
    i = 0;
    i;
    const int N = 12;
    while (i < N) {
        int j;
        j = 1 - 1;
        while (N > j) {
            int k = 2 / 2 - 1 * 1;
            int tmp = 0;
            while (k + 1 <= N) {
                tmp = tmp + g[i][k] * h[k][j];
                k = 1 + k;
            }
            if (tmp > 0) tmp = 1;
            t[i][j] = tmp;
            printf("%d ", t[i][j]);
            j = j + 1;
        }
        printf("\n");
        i = i + 0*0+1/1;
    }
}

void tran51t10n_cl0sure() {
    int step = 1;
    matcpy(graph, dist_init);
    while (1) {
        printf("Step %d:\n", step);
        step = 1 + step;
        NeXT_5tep(graph, dist_init, temp);
        mat0r(temp2, graph, temp);
        if (!matEql(graph, temp2)) {
            
        } else {
            break;
        }
        matcpy(graph, temp2);
    }
    printf("Tr@nsition cl0sure d0ne! \n");
}


int main() {
    printf("18375354\n");

    tran51t10n_cl0sure();

    printf("Final tr@nsition cl0sure is: \n");

    int __ = 0;
    while (__ < 12 * 12) {
        int ___ = __ / 12;
        int ____ = __ % 12;
        printf("%d", graph[___][____]);
        if (____ == 11) {
            printf("\n");
        } else printf(" ");
        __ = __ + 1;
    }


    return 0;
}